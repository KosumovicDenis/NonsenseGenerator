
# **Design Patterns**

## **GRASP**

> We worked according to the GRASP principles, to make sure our code was modular and extensible. We used a series of different programming principles and patterns, described below:
> - [Controller pattern](#controller)
> - [Creator pattern](#creator)
> - [Information Expert](#information-expert)
> - [High Cohesion](#high-cohesion)
> - [Low Coupling](#low-coupling)


### *Controller*

- The `Service` class implements the Controller pattern as defined by GRASP. 
   It functions as the primary coordinator for the application’s core operations, orchestrating tasks such as invoking the `Generator`, `APICaller`, and `History` components.\
   \
   Rather than performing detailed processing itself, it delegates responsibilities to specialized classes.  
   This design encapsulates the Controller’s role of handling system operations triggered by UI interactions or external inputs, thereby maintaining separation of concerns.

- The `Controller` class acts as an intermediary between the user interface (or external input sources) and the domain logic encapsulated within the `Service` class.  
   It delegates requests—such as phrase generation and history retrieval—to `Service`, managing application flow without embedding business logic.\
   \
   This aligns with the GRASP Controller responsibility, which delegates control logic away from UI and domain classes.


### *Creator*

- The `SentenceGenerator` class follows the Creator pattern by managing the instantiation of sentence-related objects.\
   \
   Because it depends heavily on and aggregates data from the `Dictionary` class to construct sentences, it is the natural creator of sentence components.\
   \
   This aligns with GRASP’s principle of assigning object creation responsibility to the class that holds or closely uses the necessary information.

- The `Dictionary` class itself embodies the Creator pattern by constructing and maintaining grammatical data structures.\
   \
   It loads and aggregates collections of nouns, verbs, adjectives, and templates from external JSON sources.  
   As the sole manager of these data collections, it naturally assumes responsibility for their creation and provision to other components.

### *Information Expert*

- The `History` class is designed according to the Information Expert principle.  
   It encapsulates all responsibilities related to managing sentence history, including persistence through loading and saving from a file.\
   \
   Since it maintains direct access to the collection of `GeneratedSentence` instances and the file system path, it appropriately holds the responsibility for data management related to sentence history.

- The `GeneratedSentence` class also adheres to the Information Expert pattern by encapsulating all details of an individual generated sentence, including its content and timestamp.\
   \
   It manages its own serialization and deserialization processes, given that it has full knowledge of its internal data representation.

### *High Cohesion*

- This ensures that each class is self-contained, easier to understand, and simpler to maintain or extend.\
\
A notable example is the **`EnvLoader`** class, which serves as a *Pure Fabrication* dedicated solely to loading environment variables.\
\
By isolating such utility functionality, the design avoids scattering responsibilities across unrelated components, further reinforcing modularity and clarity.

### *Low Coupling*

- All classes in this software were designed with minimal coupling in mind, aiming to reduce the ripple effect of changes—so that modifications to one class have limited impact on the rest of the system.\
\
This design principle contributes to maintainability, testability, and scalability, and complements the high cohesion strategy applied throughout the codebase.

## **GoF**

> In addition to GRASP, we applied several Gang of Four design patterns to solve recurring design problems using well-established, reusable solutions.  
> These patterns improved the flexibility, maintainability, and clarity of our system by introducing abstractions and separation of concerns.  
> We adopted the following GoF patterns throughout the project:
> - [Abstract Factory](#abstract-factory)
> - [Factory Method](#factory-method)
> - [Builder](#builder)
> - [Facade](#facade)
> - [Strategy](#strategy)


### *Abstract Factory*  

- The **`Dictionary`** class provides grouped grammatical elements such as nouns, adjectives, and verbs.  
This aligns loosely with the Abstract Factory pattern by offering access to families of related objects without specifying their concrete classes.



### *Factory Method*  
- The **`EnvLoader`** class encapsulates the logic required to read a file and construct a configuration object.  
It abstracts the instantiation process behind a unified interface, providing flexibility and separation of concerns.



### *Builder*
 
  - The **`SentenceGenerator`** class demonstrates builder-like behavior by assembling complex sentences step by step using templates and grammatical components.  
   Though not a formal Builder pattern, the process reflects similar intent—constructing composite objects through a controlled sequence of operations.

### *Facade*  

- The **`Service`** class acts as a facade over lower-level subsystems like `Generator`, `APICaller`, and `History`, offering a simplified interface to the core functionality.  

- The **`Controller`** class serves as an additional abstraction layer, exposing a unified access point for external clients (e.g., UI or API) to interact with the application, further hiding internal complexities.


### *Strategy*
-  The **`SentenceGenerator`** class uses interchangeable logic through the `Generator` interface, enabling different sentence construction strategies to be applied at runtime based on configuration or context.  
   This loosely mirrors the Strategy pattern.
